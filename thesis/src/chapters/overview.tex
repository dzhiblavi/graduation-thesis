%&latex
\chapter{Обзор}\label{overview}

\tbd{Содержание главы}

\section{Термины и понятия}\label{overview:terms}

\tbd{Переработать определения? Лазейки точно плохие}

\begin{definition}\label{overview:formula}
    \textbf{Булевой формулой} \footnote{https://ru.wikipedia.org/wiki/Булева\_формула} называется 
    формула логики высказываний, сорержащая логические переменные и пропозициональные связки
    $\wedge, \vee, \neg$. Множество логических переменных обозначается $V$.
\end{definition}

\begin{definition}\label{overview:function}
    \textbf{Булевой функцией} называется отображение $E\colon~ \mathcal{B}^n \to \mathcal{B}$,
    где $\mathcal{B} = \{\, 0, 1 \,\}$, а $n$ -- число различных переменных. Булева формула $F$ 
    задает булеву функцию $E_F$. Далее разница между этими понятиями для нас несущественна, поэтому
    всегда будет упоминаться булева функция $E$.
\end{definition}

\begin{definition}\label{overview:sat}
    \textbf{Задача булевой выполнимости (SAT)} --- проверить, существует ли $x \in \mathcal{B}^n$
    такой, что выполняется $E(x) = 1$.
\end{definition}

\begin{theorem}(Кук, Левин)
    \textit{Задача булевой выполнимости принадлежит классу NP-полных задач}~\cite{bib:cook-levin}.
\end{theorem}

\begin{definition}\label{overview:solver}
    \textbf{Решателем, алгоритмом A} называется алгоритм, принимающий на вход описание булевой формулы $C$
    и выдающий результат проверки булевой выполнимости соответствующей булевой функции --- $A(C)$.
    Возможны следующие результаты:
    \begin{itemize}
        \item \texttt{0}, функция невыполнима.
        \item \texttt{1}, функция выполнима. В этом случае также может быть возвращено
            удовлетворяющее функции назначение переменных $R$: $E(V \mid R) = 1$.
        \item \texttt{?}, решатель не смог решить задачу либо вследствие его неполноты, либо
            из-за нехватки ресурсов, таких как время или память.
    \end{itemize}
    Обозначим за $S(A)$ множество булевых функций, разрешимых алгоритмом $A$ за полиномиальное время.
\end{definition}

\begin{definition}\label{overview:assumption}
    \textbf{Означиванием, подстановкой} набора переменных $B \subseteq V$ называется отображение
    $\hat{b}\colon~ B \to \mathcal{B}$. Означивание можно применить к булевой функции $E$,
    результатом будет другая булева функция $E[B \mid \hat{b}] \colon \mathcal{B}^{|V| - |B|} \to
    \mathcal{B}$, возможно тождественная. Она получается из исходной путем частичной подстановки
    переменных, назначенных функцией $\hat{b}$. Множество всех означиваний множества переменных
    $B$ обозначается $\hat{B}$.
\end{definition}

\begin{definition}\label{overview:prop}
    \textbf{Вывод последствий, Unit Propagation (UP)} --- алгоритм, принимающий на вход формулу
    и назначение набора переменных. Возвращает спиков литералов (то есть значений переменых),
    выведенных из заданного назначения, или информацию о возникновении конфликта, то есть о
    невыполнимости формулы с заданным назначением. Эффективно реализован в \textsc{Minisat}~
    \cite{bib:minisat}.
\end{definition}

\begin{definition}\label{overview:backdoor}
    \textbf{Лазейкой} называется множество $B \subseteq V$ такое, что для любого из $2^{|B|}$
    означиваний $\hat{b}$ переменных из $B$ выполняется $E[B \mid \hat{b}] \equiv 0$.
    Ясно, что если для функции $E$ существует лазейка, то она невыполнима, то есть $E \equiv 0$.
\end{definition}

\begin{definition}\label{overview:rho-backdoor}
    \textbf{$\rho$-Лазейкой} называется множество $B \subseteq V$ такое, что выполняется
\[
    \left|\left\{\, \hat{b} \mid \hat{b} \in \hat{B},~ E[B \mid \hat{b}] \equiv 0 \,\right\}\right|
    \geqslant \rho \cdot 2^{|B|}.
\]
\end{definition}

\newcommand*{\prob}{\mathsf{Pr}}

\begin{definition}\label{overview:prob-backdoor}
    \textbf{$(\varepsilon, \delta)$ аппроксимация лазейки, вероятностная лазейка}. Зафиксируем
    $\varepsilon, \delta \in (0, 1)$, пожмножество переменных $B \subseteq V$ и алгоритм $A$, 
    и рассмотрим множество означиваний $\hat{B}$ в терминах $\rho$-лазейки.
    \begin{itemize}
        \item Введем на $\hat{B}$ равномерное распределение и зададим случайную величину
            \[
                \xi_B(\hat{b}) = \left[E[B \mid \hat{b}] \in S(A)\right].
            \]
            Ясно, что эта величина распределена по Бернулли с $p = \rho_B$.
        \item Тогда $B$ является $(\varepsilon, \delta)$ аппроксимацией лазейки, если
            \[
                \prob{\left[1 - \varepsilon \leqslant \frac{1}{N}\sum_{j=1}^{N}{\xi_j}\right]}
                \geqslant 1 - \delta,
            \]
            где $N \geqslant \frac{4 \ln{2/\delta}}{\varepsilon^2}$. Данное условие согласно
            теореме Чернова \tbd{paper} обеспечивает тот факт, что аппроксимация $\rho_B$,
            вычисляемая по формуле 
            \begin{equation}
                \hat{\rho}_B = \frac{1}{N} \sum_{j=1}^{N}{\xi_j}\label{overview:rho-hat},
            \end{equation}
            отклоняется от истинного значения $\rho_B$ не более, чем на $\varepsilon$ с вероятностью 
            не менее $1 - \delta$.
    \end{itemize}
\end{definition}

\startrelatedwork

\section{Последовательные решатели}\label{overview:sequential}

Понимание устройства распостраненных схем последовательных решателей играет крайне важную роль в
данной работе, так как они прямо или косвенно используются в качестве решателей подзадач,
возникающих в процессе работы описываемого алгоритма.

Опишем в общих чертах схему работы классических последовательных решателей. 
\textit{Алгоритм Дэвиса-Патнема-Логемана-Лавленда (DPLL)}~\cite{bib:dpll-1}~\cite{bib:dpll-2}
--- полный алгоритм для решения задачи булевой выполнимости, основанный на поиске с возвратом. 
Данный алгоритм заключается в разбиении задачи на подзадачи путем последовательного присвоения 
переменным булевых значений и дальнейшей проверкой на отсутствие конфликтов. Часто в данном
типе алгоритмов применяются дополнительные правила: \textit{резолюция} --- вывод значения переменных,
значения которых однозначно определяют значение дизъюнкта, \textit{исключение чистых переменных},
то есть переменных, входящих в формулу либо только с отрицанием, либо только без отрицания.

На основе алгоритма DPLL построен подход \textit{CDCL (Conflict-Driven Clause Learning, управляемое
конфликтами обучение дизъюнктам)}~\cite{bib:cdcl}. Данный подход используется во всех решателях, 
включенных в качестве компонентов в данной работе, так как является одним из самых распространенных и
эффективных. Подход расширяет семейство DPLL несколькими техниками, среди которых анализ структуры
конфликтов, запоминание конфликтных дизъюнктов, эвристики ветвления и другие. Тот факт, что
данные решатели аккумулируют определенный вид знаний, крайне важен для портфельных решателей,
описанных в разделе~\ref{overview:parallel} и также использующихся в данной работе.

\section{Параллельные решатели}\label{overview:parallel}

Параллельные решатели нацелены на ускорение процесса решения засчет увеличения утилизации
выделенных ресурсов, в частности и в особенности многоядерных и многопроцессорных систем. Рассмотрим
некоторые подходы к реализации таких алгоритмов.

\textit{Портфельные решатели} основаны на запуске диверсифицированного набора последовательных
решателей, часто основанных на алгоритме CDCL, позволяющем осуществлять обмен 
знаниями~\cite{bib:painless-sharing}. Типичными примерами таких решателей являются 
\textsc{hordesat}~\cite{bib:hordesat-portfolio} и \textsc{painless}~\cite{bib:painless}. 
Диверсификация решателей неизбежно приводит к выучиванию разных наборов дизъюнктов, ускоряя тем самым 
каждый из них по отдельности засчет обмена. В данной работе используется фреймворк 
\textsc{painless}, который предоставляет инструменты
в том числе для создания портфельного решателя. В частности, портфельный решатель 
\textsc{painless-mcomsps}, основанный на последовательном решателе \textsc{MapleCOMSPS}
~\cite{bib:maplecomsps}, является победителем параллельного 
трека Sat Competition~\footnote{https://satcompetition.github.io/2021/slides/ISC2021-fixed.pdf} и 
используется в предлагаемом алгоритме.

\tbd{Может вообще убрать? Никак не используется}
\textit{Алгоритмы локального поиска}~\cite{bib:local-search}. Данный подход основан на параллельном
изменении значений переменных, и в данной работе не используется.

\textit{Алгоритмы разделяй-и-властвуй}~\cite{bib:divide-and-conquer}. В отличие от портфельных 
решателей, данное семейство алгоритмов не занимается параллельным решением одной и той же задачи. 
Напротив, исходная задача разбивается на подзадачи тем или иным способом, после чего полученные 
подзадачи решаются параллельно. Пример такого решателя основан на упомянутом фреймворке \textsc{painless}
~\cite{bib:dac-painless}. Основной проблемой данного подхода является тот факт, что подпространства 
поиска очень часто имеют значительно разную сложность решения. В данной работе также будет произведена
попытка решить эту проблему: предлагаемый в данной работе алгоритм относится к данному семейству
решателей и является совершенно новым в том смысле, что на момент разработки не существует
полноценных конкурентоспособных алгоритмов, основанных на идее разделения задачи на подзадачи через
поиск вероятностных лазеек. Тем не менее, результаты, продемонстрированные в работе \tbd{paper},
дают основания полагать, что на основе этой идеи можно создать решатель, имеющий высокую
производительность.

\finishrelatedwork

\chapterconclusion

\tbd{Заключение}
